{
  "hash": "fc29b7aeef941f76eb53c5ba66e7493c",
  "result": {
    "markdown": "---\ntitle: \"New Zealand Sheep\"\ndescription: \"Day 7 of the #30DayMapChallenge - Raster\"\nauthor: \"Michelle Evans\"\ndate: \"2022-11-07\"\ndraft: false\nimage: sheep-header.jpg\nexecute:\n  warning: false\n  message: false\n---\n\n\n\n![*Image Credit: <a href=\"https://unsplash.com/ja/@house_42?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Taylor Brandon</a> on <a href=\"https://unsplash.com/s/photos/sheep-new-zealand?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>*](sheep-header.jpg)\n\nToday's goal was to learn about placing some inset images into plots. I had originally planned on using something via `ggsave`, but because I was just using plain `png` images, it was easier to insert these using `richtext` option from the [`ggtext`](https://wilkelab.org/ggtext/). Although it is meant to be used to render HTML or markdown text, we can also make use of it's ability to render HTML to add images.\n\nFor the raster, I decided to use density of sheep from the [Gridded Livestock of the World](https://www.fao.org/livestock-systems/global-distributions/en/) dataset. This contains global rasters of the density of common livestock and is great for when you want to know just *how* many sheep are there in New Zealand?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(ggtext)\nlibrary(showtext)\nlibrary(terra)\n\n#add custom fonts\nfont_add('fa-brands', here::here('fonts/fa-brands-400.ttf'))\nfont_add('andika', here::here('fonts/Andika-Regular.ttf'))\nshowtext_auto()\n\nlibrary(dplyr)\n```\n:::\n\n\n# Create basemap data\n\nWhile we don't end up using a polygon of the outline of New Zealand in the final map, we will use it for cropping the raster to the outline of the country. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnz.poly <- spData::world %>%\n  filter(iso_a2 == \"NZ\") %>%\n  dplyr::select(iso_a2)\n```\n:::\n\n\nWe then load the raster of sheep. I've already roughly cropped this to the area surrounding New Zealand to save on file size. We then crop the raster using our outline of New Zealand, making sure we set `mask = TRUE` so it crops to the outline. If this was set to false, it would only crop it to the extent of the polygon and we would have some messy raster cells nearby. I also transform the scale the number of sheep to be by the 1000. It turns out, New Zealand has **a lot** of sheep.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsheep <- rast(\"nzSheep.tif\")\n#crop to new zeland outline\nsheep <- crop(sheep, nz.poly, mask = TRUE, touches = TRUE)\nsheep.df <- as.data.frame(sheep, xy = TRUE) %>%\n  mutate(sheep1k = nzSheep/1000)\n```\n:::\n\n\n# Create the map\n\nOne frustrating aspect of using a scripted language to create a map is that the fine-tuning of placement and alignment of items can become tedious as you slowly change the numbers corresponding to coordinates to identify the best location. However, a great thing about this is that, once you have the general location sorted, you can automate some of this. \n\nBelow, I set a kind of architecture for where I'd like my insets to go by defining the base coordinates of the first inset and the spacing between insets, and then calling those objects in the plot. Then, when something changes, I can change the measures in one place instead of at multiple places within the `ggplot` call. It also cleans up the code in the `ggplot` call because we just use that one dataframe, insead of an `annotate` line for each image.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#set colors\nblue.bg <- \"#A4C3D2\"\n#starting sheep coordinates\nsheep.x <- 169.5\nsheep.y <- -37.4\nsheep.width <- 0.75\nsheep.height <- 1.2\n#create dataframe of sheep icon coordinates\nsheep.icons <- data.frame(x = rep(c(sheep.x + (c(1:3)*sheep.width)), 2),\n                          y = rep(c(sheep.y, sheep.y-sheep.height), each = 3),\n                          label = \"<img src='sheep-white.png' width='30'/>\")\n\n#caption label\n#define caption for easier reading\ncaption.lab <- paste0(\"#30DayMapChallenge<br>\",\n                      \"<b>Source: </b>GLW3, Konkapp, DinosoftLabs<br>\",\n                      \"<span style='font-family:fa-brands;'>&#xf113;</span> mvevans89\")\n\n#create sheep plot\nsheep.map <- ggplot() +\n  geom_raster(data = sheep.df, aes(x = x, y = y, fill = sheep1k)) +\n  scale_fill_gradient(high = \"#fff2cb\", low = \"#e7acf2\", \n                      name = bquote(atop(Thousand~Sheep~phantom(),\n                                          per~\"10km\"^2))) +\n  guides(fill = guide_colourbar(title.position=\"top\", title.hjust = 0)) +\n  #add title\n  annotate(geom = \"richtext\", x = 169.5, y = -36, label = \"New Zealand has the<br>highest person:sheep ratio in the world\", family = \"andika\") +\n  #add in little emojis\n  #human\n  annotate(geom = \"richtext\",  label =\"<img src='user-white.png' width='50'/>\",\n           x = 168, y = -38, fill = NA, color = NA) +\n  #colon\n  annotate(geom = \"richtext\", fill = NA, color = NA, text.color = \"white\", label = \":\", \n           family = \"andika\", x = 168.75, y = -38, size = 14) +\n  #add six sheep using dimensions assigned above\n  geom_richtext(data = sheep.icons, aes(x = x, y =y, label = label), fill = NA, color = NA) +\n  # add caption\n  annotate(geom = \"richtext\", x = 178.40, y = -34.5, fill = NA, label.color = NA,\n                color = \"gray20\", size = 2.5, hjust = 1,\n           label = caption.lab) +\n  theme(panel.background = element_rect(\"#A4C3D2\"),\n        panel.grid = element_blank(),\n        axis.text = element_blank(),\n        axis.title = element_blank(),\n        axis.ticks = element_blank(),\n        legend.position = c(0.85,0.1),\n        legend.direction = \"horizontal\",\n        legend.text = element_text(size = 8, color = \"gray20\", family = \"sans\"),\n        legend.title = element_text(color = \"gray20\", family = \"sans\"),\n        legend.background = element_rect(fill = \"#A4C3D2\"))\n```\n:::\n\n\n\n\n![](sheep-map.png)\n  \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}