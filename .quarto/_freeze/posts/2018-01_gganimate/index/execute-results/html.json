{
  "hash": "2436b6fb98139f53c9525402eaaf65a2",
  "result": {
    "markdown": "---\ntitle: \"Animating Maps with gganimate\"\nauthor: \"Michelle Evans\"\ndate: \"1/01/2018\"\ndraft: true\nimage: \"map-clipart.png\"\n---\n\n\nNOTE TO SELF: This needs to be updated to work with gganimate in 2022\n\nI've recently been working on a monthly yellow fever dataset from Brazil that spans fourteen years. Overall, there are over 5600 spatial units and 168 months (that's nearly 1,000,000 rows of data for those of you keeping track). It is great to have access to so much data, but sometimes visualizing it can be a bit of a pain, especially when we are trying to look at patterns across time and space. Static maps can show the spatial patterns, time series plots can show seasonal patterns and can even be broken down to regions, but visualizing thousands of lines becomes basically uninterpretable. Luckily, in the age of computers, we are not limited to a static map, and can instead loop together maps over time using animation.\n\nThere are many ways to create animated plots in R, including interactive tools such as [shiny](https://shiny.rstudio.com/articles/sliders.html), but as a ggplot user I'm going to focus on a package called `gganimate`. This package follows all the grammar of ggplot and simply adds an aesthetic called `frame` that will looped over.\n\nTo illustrate this, let's look at the presidential election results from the 20th century, taking advantage of a dataset in the `choroplethr` package. This package also has it's own function to animate maps (`choroplethr_animate`), but I prefer using gganimate as it is more customizable and saves the resulting image as a gif, rather than an html file. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load packages\nlibrary(choroplethr)\nlibrary(tidyverse)\n#devtools::install_github(\"dgrtwo/gganimate\")\nlibrary(gganimate)\nlibrary(maps)\nlibrary(htmltools)\n\n#download president data\ndata(\"df_president_ts\")\n```\n:::\n\n\n\nFor the actual spatial data, I use the data that comes with `ggplot` which means I don't need to fortify any SpatialDataFrames into ggplot-readable objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus <- map_data(\"state\")\n```\n:::\n\n\nI'll focus only on election outcomes post-1900 to reduce the number of political parties we'll need to map. The easiest way to do this is via `dplyr` after transforming the dataframe into a long dataframe. I will also sort any candidates that aren't Democrat or Republican into a new category, Third Party.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelections <- df_president_ts %>%\n  #gather into long data\n  gather(year, winner, `1789`:`2012`) %>%\n  #filter only elections after 1900\n  filter(year >= 1900) %>%\n  #join with state polygons\n  right_join(us, by = \"region\") %>%\n  mutate(party = case_when(\n    winner %in% c(\"SR\", \"I\", \"AI\", \"PR\") ~ \"Third Party\",\n    winner == \"D\" ~ \"Democrat\",\n    winner == \"R\" ~ \"Republican\"\n  ))\n```\n:::\n\n\nNow I will set up a base map to start editing before we animate it all. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  # polygons\n  geom_polygon(data = elections, aes(x = long, \n                                     y = lat, \n                                     group = group, \n                                     fill = party),\n                color = \"gray20\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nThis map looks pretty horrible, but we can edit the format and colors. Much of this is borrowed from [Timo Grossenbacher's blog post on creating beautiful maps in ggplot](https://timogrossenbacher.ch/2016/12/beautiful-thematic-maps-with-ggplot2-only). I like to create this as a separate theme object which I can then add to the ggplot object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_map <- function(...) {\n  theme_minimal() +\n  theme(\n    axis.line = element_blank(),\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank(),\n    axis.ticks = element_blank(),\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.grid.major = element_blank(),\n    plot.background = element_rect(fill = \"#f5f5f2\", color = NA), \n    panel.background = element_rect(fill = \"#f5f5f2\", color = NA), \n    legend.background = element_rect(fill = \"#f5f5f2\", color = NA),\n    panel.border = element_blank(),\n    legend.position = \"bottom\",\n    ...\n  )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  # polygons\n  geom_polygon(data = elections, aes(x = long, \n                                       y = lat, \n                                       group = group, \n                                       fill = party),\n                 color = \"#f5f5f2\") +\n  theme_map() +\n  coord_map(\"albers\", lat0=30, lat1=40) + \n  scale_fill_manual(values = c(\"#05204A\", \"#A24936\", \"#3E5641\"), \n                    na.value = \"gray70\",\n                    name = \"Winning Party\") +\n  labs(x = NULL, \n       y = NULL, \n       title = \"US Presidential Election Results: 1900\" \n       )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nWhen using `gganimate`, the variable that you set as the frame aesthetic will be added to the title. This means I can then just set the title as \"US Presidential Election Results: \", and the year number (i.e. 1900) will be appended onto the end.\n\nUnlike before, where I was calling data in the `geom_polygon` call, gganimate requires the data and frame aesthetic to be called in the original ggplot call.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot(data = elections, aes(frame = year)) +\n  # polygons\n  geom_polygon(aes(x = long, y = lat, group = group, fill = party),\n                 color = \"#f5f5f2\") +\n  theme_map() +\n  coord_map(\"albers\", lat0=30, lat1=40) + \n  scale_fill_manual(values = c(\"#05204A\", \"#A24936\", \"#3E5641\"), \n                    na.value = \"gray70\",\n                    name = \"Winning Party\") +\n  ggtitle(\"US Presidential Election Results: \")\n```\n:::\n\n\nNow I just call this plot `p1` in the `gganimate` function, setting the `interval` to 1.5 seconds.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngganimate(p1, interval = 1.5)\n```\n:::\n\n\nEssentially, what this function is doing is creating these plots, saving them in virtual memory, and then combining them using Image Magick (which can also be accessed via the command line). The ease of being able to combine this within one R script, rather than having to run shell scripts from within R, makes this an efficient, and reproducible, way to animate plots.\n\nThe code above will open the image in your Image Viewer. If you want to save the image, simply include the filename in the call.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngganimate(p1, interval = 1.5, filename = \"animationmap.gif\")\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}