{"title":"Dummy Variables for Dummies","markdown":{"yaml":{"title":"Dummy Variables for Dummies","description":"How to create dummy variables within a dataframe","author":"Michelle Evans","date":"2021-02-27","draft":false,"image":"dummy-book-120.png","execute":{"warning":false}},"headingText":"What are dummy variables?","containsRefs":false,"markdown":"\n\n\nAs you may have guessed from the cliched title that I couldn't resist, this post is about dummy variables. Specifically, comparing a couple of different ways to create them in R, and seeing which is fastest.\n\n```{r}\n#| warning: false\n#| message: false\n#| include: false\nlibrary(ggplot2); theme_set(theme_bw())\nlibrary(microbenchmark)\n```\n\n\nDummy variables, sometimes called indicator variables, are a way to encode categorical variables as numerical (often binomial), so that we can model them in a regression. Luckily, R will often deal with creating these dummy variables under the hood when we use something like `lm` to model a regression, but this is not true for all methods.\n\nAs an example, let's say we are interested in the effect of three different types of crops (corn, wheat, rice) on soil nitrogen content (% N). The dataset may look something like this:\n\n```{r}\nn.sample <- 100000 #how many rows of data will you have?\ncrop.types <- c(\"corn\", \"rice\", \"wheat\") #what are the levels of your categorical variable?\nnitrogen.data <- data.frame(\n  crop_type = crop.types[sample(1:3, n.sample, replace = T)],\n  perc_N = runif(n.sample, min = 0, max =1 )\n)\nhead(nitrogen.data)\n```\n\nIn R, we may model this in a regression framework with the following code:\n\n```{r, eval = F}\nlm(perc_N ~ 0 + crop_type,\n   data = nitrogen.data)\n```\n\nThis corresponds to a regression equation that may look something like this:\n\n$y_i = \\beta_{1}corn_i + \\beta_2wheat_i + \\beta_3rice_i +\\epsilon$\n\nwhere:\n\n- $y_i$ is the % N of the field, *i* </br>\n\n- $\\beta_1$, $\\beta_2$, $\\beta_3$ are the coefficients for the effects of corn, wheat, and rice, respectively\n\n- $corn_i$, $wheat_i$, $rice_i$ are all binomial variables (0/1) for the type of crop grown in field *i*.\n\nThe model formula in the call to `lm` looks much simpler than this. That is because, under the hood, R is creating dummy variables from our `crop_type` variable, creating a binomial variable for each level of our categorical variable, without us needing to specify it.\n\n\n![](dummy_crop-type.png)\n\nWhen recording our data, it is much easier to do it like the data frame on the left, which is more human readable. Then we can turn it into the data frame on the right programmatically using R. This blog post will go over several ways to do this:\n\n1. the `model.matrix` function in base R\n2. via the `pivot_wider` function of the `tidyr` package (tidyverse framework)\n3. the `fastDummies`package\n\nAnd then compare the speeds on a larger dataset.\n\n# Using base R\n\nIf you don't want to install any additional packages, you can do this in base R via the `model.matrix` function. It takes as an argument a model formula, but note that you need to add the `~ 0 +` to the formula so that it doesn't include an intercept when creating the dummy data frame. This will create a matrix without the response variable, so you will may want to join it back to the original dataset.\n\n```{r}\nbase.mat <- model.matrix(object = ~0 + crop_type, data = nitrogen.data)\n#join with original data\nbase.df <- cbind(nitrogen.data, base.mat) \n\nhead(base.df)\n```\n\nThis is essentially what is happening behind the scenes when you do a linear regression without creating a dummy variable first. In fact the formula used in this call is the same as the one above.\n\n# Using the tidyverse\n\nYou can also do this using the `pivot_wider` function in `tidyr`. Using this method, you create a dummy_value column with all 1's and then spread that value across each of the categories from the `names_from` column.\n\n```{r}\n#| warning: false\n#| message: false\nlibrary(dplyr)\nlibrary(tidyr)\npivot_df <- nitrogen.data %>%\n  #create dummy value column\n  mutate(dummy_val = 1) %>%\n  #spread across crop type\n  pivot_wider(names_from = crop_type, values_from = dummy_val, values_fill = 0)\n\nhead(pivot_df)\n```\n\nNote that we also supply the value to fill in a cell when a row doesn't correspond to that category, via the `values_fill` argument. \n\n# Using the `fastDummies` package\n\nThe play dataset we are using for this is only 100,000 rows and we are only concerned with one categorical variable with three levels, but real data may have many more rows and more complicated categorical variables, which can take much longer to turn into dummy variables. Hence the [`fastDummies` package](https://jacobkap.github.io/fastDummies/).\n\nUsing this package is super simple, and relies on one function to create dummy variables across columns. The function will by default turn all character or categorical variables into dummy variables, but you can also specify the columns you would like to \"dummify\" with the `select_columns` argument. \n\n```{r}\n#| warning: false\n#| message: false\nlibrary(fastDummies)\nfastdummy.df <- dummy_cols(nitrogen.data, select_columns = \"crop_type\")\n\nhead(fastdummy.df)\n```\n\n\n# Comparing the speed\n\nThere isn't much difference between these methods code-wise, except the tidyverse method which is a couple of lines longer. Using `pivot_wider` also probably scales-up the worst, as you will need to repeat the technique for every categorical variable column you have, while the other methods allow you specify additional columns in the function itself. So we'll use `microbenchmark` to see which method is fastest when applied to a dataset of 100k rows and a categorical variable with 26 levels.\n\n```{r}\nn.sample = 100000\nfast.data <- data.frame(response = rnorm(n.sample, 0,1),\n                        category = sample(LETTERS, n.sample, replace = T))\n\ntime.test <- microbenchmark(\n  base = cbind(fast.data, model.matrix(object = ~0 + category, data = fast.data)),\n  tidyr_way = fast.data %>% mutate(dummy_val = 1) %>% pivot_wider(names_from = category, values_from = dummy_val, values_fill = 0),\n  fast_dummies = dummy_cols(fast.data, select_columns = \"category\"),\n  times = 20\n)\n```\n\n```{r}\n#| echo: false\n#| warning: false\ntime.test\nautoplot(time.test)\n```\n\nSurprisingly, the method using `tidyr` was actually the fastest way to create dummy variables, even though tidyverse is often critiqued for being relatively slow. It also required the most code and wasn't as clean of a workflow as the others, so there is a trade-off there. It was only about 3x slower than `fastDummies`, which is another relatively fast option when creating dummy variables for a larger dataset.\n\nI personally like the ability to pipe into the tidyr method within a tidyverse workflow and will probably continue to use that since it is the fastest, even if it is a couple of more lines of code.\n","srcMarkdownNoYaml":"\n\n\nAs you may have guessed from the cliched title that I couldn't resist, this post is about dummy variables. Specifically, comparing a couple of different ways to create them in R, and seeing which is fastest.\n\n```{r}\n#| warning: false\n#| message: false\n#| include: false\nlibrary(ggplot2); theme_set(theme_bw())\nlibrary(microbenchmark)\n```\n\n# What are dummy variables?\n\nDummy variables, sometimes called indicator variables, are a way to encode categorical variables as numerical (often binomial), so that we can model them in a regression. Luckily, R will often deal with creating these dummy variables under the hood when we use something like `lm` to model a regression, but this is not true for all methods.\n\nAs an example, let's say we are interested in the effect of three different types of crops (corn, wheat, rice) on soil nitrogen content (% N). The dataset may look something like this:\n\n```{r}\nn.sample <- 100000 #how many rows of data will you have?\ncrop.types <- c(\"corn\", \"rice\", \"wheat\") #what are the levels of your categorical variable?\nnitrogen.data <- data.frame(\n  crop_type = crop.types[sample(1:3, n.sample, replace = T)],\n  perc_N = runif(n.sample, min = 0, max =1 )\n)\nhead(nitrogen.data)\n```\n\nIn R, we may model this in a regression framework with the following code:\n\n```{r, eval = F}\nlm(perc_N ~ 0 + crop_type,\n   data = nitrogen.data)\n```\n\nThis corresponds to a regression equation that may look something like this:\n\n$y_i = \\beta_{1}corn_i + \\beta_2wheat_i + \\beta_3rice_i +\\epsilon$\n\nwhere:\n\n- $y_i$ is the % N of the field, *i* </br>\n\n- $\\beta_1$, $\\beta_2$, $\\beta_3$ are the coefficients for the effects of corn, wheat, and rice, respectively\n\n- $corn_i$, $wheat_i$, $rice_i$ are all binomial variables (0/1) for the type of crop grown in field *i*.\n\nThe model formula in the call to `lm` looks much simpler than this. That is because, under the hood, R is creating dummy variables from our `crop_type` variable, creating a binomial variable for each level of our categorical variable, without us needing to specify it.\n\n\n![](dummy_crop-type.png)\n\nWhen recording our data, it is much easier to do it like the data frame on the left, which is more human readable. Then we can turn it into the data frame on the right programmatically using R. This blog post will go over several ways to do this:\n\n1. the `model.matrix` function in base R\n2. via the `pivot_wider` function of the `tidyr` package (tidyverse framework)\n3. the `fastDummies`package\n\nAnd then compare the speeds on a larger dataset.\n\n# Using base R\n\nIf you don't want to install any additional packages, you can do this in base R via the `model.matrix` function. It takes as an argument a model formula, but note that you need to add the `~ 0 +` to the formula so that it doesn't include an intercept when creating the dummy data frame. This will create a matrix without the response variable, so you will may want to join it back to the original dataset.\n\n```{r}\nbase.mat <- model.matrix(object = ~0 + crop_type, data = nitrogen.data)\n#join with original data\nbase.df <- cbind(nitrogen.data, base.mat) \n\nhead(base.df)\n```\n\nThis is essentially what is happening behind the scenes when you do a linear regression without creating a dummy variable first. In fact the formula used in this call is the same as the one above.\n\n# Using the tidyverse\n\nYou can also do this using the `pivot_wider` function in `tidyr`. Using this method, you create a dummy_value column with all 1's and then spread that value across each of the categories from the `names_from` column.\n\n```{r}\n#| warning: false\n#| message: false\nlibrary(dplyr)\nlibrary(tidyr)\npivot_df <- nitrogen.data %>%\n  #create dummy value column\n  mutate(dummy_val = 1) %>%\n  #spread across crop type\n  pivot_wider(names_from = crop_type, values_from = dummy_val, values_fill = 0)\n\nhead(pivot_df)\n```\n\nNote that we also supply the value to fill in a cell when a row doesn't correspond to that category, via the `values_fill` argument. \n\n# Using the `fastDummies` package\n\nThe play dataset we are using for this is only 100,000 rows and we are only concerned with one categorical variable with three levels, but real data may have many more rows and more complicated categorical variables, which can take much longer to turn into dummy variables. Hence the [`fastDummies` package](https://jacobkap.github.io/fastDummies/).\n\nUsing this package is super simple, and relies on one function to create dummy variables across columns. The function will by default turn all character or categorical variables into dummy variables, but you can also specify the columns you would like to \"dummify\" with the `select_columns` argument. \n\n```{r}\n#| warning: false\n#| message: false\nlibrary(fastDummies)\nfastdummy.df <- dummy_cols(nitrogen.data, select_columns = \"crop_type\")\n\nhead(fastdummy.df)\n```\n\n\n# Comparing the speed\n\nThere isn't much difference between these methods code-wise, except the tidyverse method which is a couple of lines longer. Using `pivot_wider` also probably scales-up the worst, as you will need to repeat the technique for every categorical variable column you have, while the other methods allow you specify additional columns in the function itself. So we'll use `microbenchmark` to see which method is fastest when applied to a dataset of 100k rows and a categorical variable with 26 levels.\n\n```{r}\nn.sample = 100000\nfast.data <- data.frame(response = rnorm(n.sample, 0,1),\n                        category = sample(LETTERS, n.sample, replace = T))\n\ntime.test <- microbenchmark(\n  base = cbind(fast.data, model.matrix(object = ~0 + category, data = fast.data)),\n  tidyr_way = fast.data %>% mutate(dummy_val = 1) %>% pivot_wider(names_from = category, values_from = dummy_val, values_fill = 0),\n  fast_dummies = dummy_cols(fast.data, select_columns = \"category\"),\n  times = 20\n)\n```\n\n```{r}\n#| echo: false\n#| warning: false\ntime.test\nautoplot(time.test)\n```\n\nSurprisingly, the method using `tidyr` was actually the fastest way to create dummy variables, even though tidyverse is often critiqued for being relatively slow. It also required the most code and wasn't as clean of a workflow as the others, so there is a trade-off there. It was only about 3x slower than `fastDummies`, which is another relatively fast option when creating dummy variables for a larger dataset.\n\nI personally like the ability to pipe into the tidyr method within a tidyverse workflow and will probably continue to use that since it is the fastest, even if it is a couple of more lines of code.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"toc-depth":3,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","theme":"minty","title-block-banner":false,"title":"Dummy Variables for Dummies","description":"How to create dummy variables within a dataframe","author":"Michelle Evans","date":"2021-02-27","draft":false,"image":"dummy-book-120.png"},"extensions":{"book":{"multiFile":true}}}},"draft":false,"projectFormats":["html"]}