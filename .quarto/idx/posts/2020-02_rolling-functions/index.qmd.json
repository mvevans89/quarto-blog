{"title":"Rolling Functions Along columns","markdown":{"yaml":{"title":"Rolling Functions Along columns","description":"How to apply aggregate functions that 'roll' across data","author":"Michelle Evans","date":"2/11/2020","draft":false,"image":"roll_alignments.png"},"containsRefs":false,"markdown":"\n\nRolling, or window, functions allow you to apply a function over a window of size `n` of a vector, such as a column in a dataframe. This is especially useful when you want to know the accumulation of some variable over time, like precipitation over the past month or the count of some occurrence in a surrounding number of days.\n\nTo follow this you'll need the following packages:\n\n```{r}\n#| warning: false\n#| message: false\n\nlibrary(RcppRoll)\nlibrary(ggplot2); theme_set(theme_bw())\nlibrary(dplyr)\n```\n\nI recently used rolling functions to deal with a data puzzle of my own. We had case data for a respiratory disease across multiple states and wanted to identify the start of the oubreak in each state. In this case, a state was considered in an outbreak after three consecutive days of new cases. The data looked something like this:\n\n```{r}\nset.seed(8675309)\n#create simulated case data\ncase.data <- data.frame(expand.grid(state = c(\"Georgia\", \"Florida\", \"North Carolina\", \"Alabama\", \"Mississippi\"),\n  day = seq(1,50))) %>%\n  #simulate cases\n  rowwise() %>%\n  mutate(cases = rpois(1,lambda = day^(1/3)))\n\n#randomly add some zeros to the beginning of the time series\nfor (i in 1:length(unique(case.data$state))){\n  this.zero.index <- sample(1:30, rpois(1,lambda=8))\n  case.data <- mutate(case.data, cases = case_when(\n    state == unique(case.data$state)[i] & day %in% this.zero.index ~ as.integer(0),\n    TRUE ~ cases\n  ))\n}\n\nhead(case.data)\n```\n\nAnd this is what the cumulative cases would look like by state:\n\n```{r}\ncase.data %>%\n  group_by(state) %>%\n  mutate(cumul.case = cumsum(cases)) %>%\n  ggplot(aes(x = day, y = cumul.case, color = state)) +\n  geom_line() +\n  xlim(0,15) +\n  ylim(0,35)\n```\n\nThe steps to finding the first day of an outbreak (i.e. the first day of three consecutive days with cases) are as follows:\n\n1. create a binary column `pos_cases` where 1 is cases>0 and 0 is cases=0\n2. create a column that is the cumulative sum of `pos_cases` over the prior three days, ranging from 0 - 3, with 3 signifyingp an outbreak\n3. find the first day of the outbreak for each state\n\nUse an `ifelse` statement to create the new column `pos_cases`\n\n```{r}\ncase.data <- case.data %>%\n  mutate(pos_cases = ifelse(cases>0,1,0))\n\nhead(case.data)\n```\n\nUse the `roll_sum` function from the RcppRoll package to calculate the number of days in the past three days that had cases. I group by `state` here since we want to do it for each state. \n\n`n` corresponds to the window size, here 3 and the alignment of the window is specified as either \"center\", \"left\", or \"right\". The easiest way to translate this to a column is to think of the column as a vector, so \"right\" would mean the window includes cells before the focal cell. \n\n\n![A schematic of how different \"rolling\" functions are applied to data.](roll_alignments.png)\n\n\nThe final argument is `fill` which provides a value to fill in cells that cannot be calculated because their window is incomplete. For this example, it would be days 1 and 2.\n\n```{r}\ncase.data <- case.data %>%\n  group_by(state) %>%\n  arrange(day) %>%\n  mutate(sum_3day = roll_sum(x = pos_cases, n = 3, align = \"right\", fill = NA)) %>%\n  ungroup()\n\narrange(case.data, state, day)[1:8,]\n```\n\nFinally, identify the first day of each outbreak by filtering the dataset only to those days that were the third day of the consecutive three days of cases, finding the minimum day for each state, and subtracting two to get to the start of the outbreak (since it began two days prior to when the outbreak was categorized)\n\n```{r}\noutbreak.day <- case.data %>%\n  filter(sum_3day == 3) %>%\n  group_by(state) %>%\n  summarise(outbreak_day = min(day)-2) %>%\n  ungroup()\n\noutbreak.day\n```\n\nThe `roll` family of functions is useful for many data manipulations over time and includes variations such as `roll_min`, `roll_min` and `roll_max`. All work similar to the `roll_sum` one described above.\n\n","srcMarkdownNoYaml":"\n\nRolling, or window, functions allow you to apply a function over a window of size `n` of a vector, such as a column in a dataframe. This is especially useful when you want to know the accumulation of some variable over time, like precipitation over the past month or the count of some occurrence in a surrounding number of days.\n\nTo follow this you'll need the following packages:\n\n```{r}\n#| warning: false\n#| message: false\n\nlibrary(RcppRoll)\nlibrary(ggplot2); theme_set(theme_bw())\nlibrary(dplyr)\n```\n\nI recently used rolling functions to deal with a data puzzle of my own. We had case data for a respiratory disease across multiple states and wanted to identify the start of the oubreak in each state. In this case, a state was considered in an outbreak after three consecutive days of new cases. The data looked something like this:\n\n```{r}\nset.seed(8675309)\n#create simulated case data\ncase.data <- data.frame(expand.grid(state = c(\"Georgia\", \"Florida\", \"North Carolina\", \"Alabama\", \"Mississippi\"),\n  day = seq(1,50))) %>%\n  #simulate cases\n  rowwise() %>%\n  mutate(cases = rpois(1,lambda = day^(1/3)))\n\n#randomly add some zeros to the beginning of the time series\nfor (i in 1:length(unique(case.data$state))){\n  this.zero.index <- sample(1:30, rpois(1,lambda=8))\n  case.data <- mutate(case.data, cases = case_when(\n    state == unique(case.data$state)[i] & day %in% this.zero.index ~ as.integer(0),\n    TRUE ~ cases\n  ))\n}\n\nhead(case.data)\n```\n\nAnd this is what the cumulative cases would look like by state:\n\n```{r}\ncase.data %>%\n  group_by(state) %>%\n  mutate(cumul.case = cumsum(cases)) %>%\n  ggplot(aes(x = day, y = cumul.case, color = state)) +\n  geom_line() +\n  xlim(0,15) +\n  ylim(0,35)\n```\n\nThe steps to finding the first day of an outbreak (i.e. the first day of three consecutive days with cases) are as follows:\n\n1. create a binary column `pos_cases` where 1 is cases>0 and 0 is cases=0\n2. create a column that is the cumulative sum of `pos_cases` over the prior three days, ranging from 0 - 3, with 3 signifyingp an outbreak\n3. find the first day of the outbreak for each state\n\nUse an `ifelse` statement to create the new column `pos_cases`\n\n```{r}\ncase.data <- case.data %>%\n  mutate(pos_cases = ifelse(cases>0,1,0))\n\nhead(case.data)\n```\n\nUse the `roll_sum` function from the RcppRoll package to calculate the number of days in the past three days that had cases. I group by `state` here since we want to do it for each state. \n\n`n` corresponds to the window size, here 3 and the alignment of the window is specified as either \"center\", \"left\", or \"right\". The easiest way to translate this to a column is to think of the column as a vector, so \"right\" would mean the window includes cells before the focal cell. \n\n\n![A schematic of how different \"rolling\" functions are applied to data.](roll_alignments.png)\n\n\nThe final argument is `fill` which provides a value to fill in cells that cannot be calculated because their window is incomplete. For this example, it would be days 1 and 2.\n\n```{r}\ncase.data <- case.data %>%\n  group_by(state) %>%\n  arrange(day) %>%\n  mutate(sum_3day = roll_sum(x = pos_cases, n = 3, align = \"right\", fill = NA)) %>%\n  ungroup()\n\narrange(case.data, state, day)[1:8,]\n```\n\nFinally, identify the first day of each outbreak by filtering the dataset only to those days that were the third day of the consecutive three days of cases, finding the minimum day for each state, and subtracting two to get to the start of the outbreak (since it began two days prior to when the outbreak was categorized)\n\n```{r}\noutbreak.day <- case.data %>%\n  filter(sum_3day == 3) %>%\n  group_by(state) %>%\n  summarise(outbreak_day = min(day)-2) %>%\n  ungroup()\n\noutbreak.day\n```\n\nThe `roll` family of functions is useful for many data manipulations over time and includes variations such as `roll_min`, `roll_min` and `roll_max`. All work similar to the `roll_sum` one described above.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"toc-depth":3,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.353","theme":"minty","title-block-banner":false,"title":"Rolling Functions Along columns","description":"How to apply aggregate functions that 'roll' across data","author":"Michelle Evans","date":"2/11/2020","draft":false,"image":"roll_alignments.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}